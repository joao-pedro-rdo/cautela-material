joao-pedro-rdo: estou definindo um adapter em typescript como que eu posso resolver esse problema do datetime que minha aplicação usa ?

VS Code: Vou te ajudar a resolver o problema com o tipo `DateTime` em TypeScript. Vou buscar informações sobre TypeScript no VS Code para dar a melhor orientação. O problema que você está enfrentando é que `DateTime` não é um tipo nativo do TypeScript. Vou te ajudar a resolver isso de algumas maneiras:

## Opção 1: Usar o tipo Date nativo do JavaScript/TypeScript

O tipo mais simples e direto seria usar `Date`:

 Opção 2: Instalar a biblioteca Luxon (recomendado)

Se você quiser usar `DateTime` da biblioteca Luxon, que é mais robusta para manipulação de datas:

1. Instale o Luxon e seus tipos:
porte o tipo no seu arquivo:
ção 3: Criar um alias de tipo personalizado

Você pode criar um alias de tipo para facilitar futuras mudanças:

Recomendação:** Use a Opção 2 (Luxon) se você precisar de funcionalidades avançadas de manipulação de datas, ou a Opção 1 (Date nativo) se você quer simplicidade.

Você pode usar o comando **TypeScript: Reiniciar Servidor TS** para garantir que as mudanças sejam reconhecidas:



Mostrar na Paleta de Comandos

joao-pedro-rdo: Agora preciso de uma ajuda eu estou usando orientação a objeotos e desig patterns para desenvolver, como que posso ajustar meus resolvers em #file:resolvers.ts  com minhas classes #file:Icautela.ts  como que posso arquiturtara isso de acordo com orientação a objetos e GraphQL


GitHub Copilot: Analisando seu código, vou te ajudar a implementar uma arquitetura orientada a objetos com design patterns adequados para GraphQL. Aqui está uma proposta de refatoração:

## 1. Primeiro, vamos corrigir os tipos DateTime

````typescript
import { ICautelaAdapter } from "./adapter";

class Cautela implements ICautelaAdapter {
  public id: string;
  public nomeCautelador: string;
  public contatoCautelador: string;
  public deOnde: string;
  public motivoCautela: string;
  public dataHoraCautela: Date;
  public previsaoRetorno: Date;
  public cauteladorResponsavel: string;
  public devolvido: boolean;
  public dataHoraDevolucao: Date | null;
  public observacoes: string;
  public createdAt: Date;
  public updatedAt: Date;

  constructor(obj: ICautelaAdapter) {
    this.id = obj.id;
    this.nomeCautelador = obj.nomeCautelador;
    this.contatoCautelador = obj.contatoCautelador;
    this.deOnde = obj.deOnde;
    this.motivoCautela = obj.motivoCautela;
    this.dataHoraCautela = new Date(obj.dataHoraCautela);
    this.previsaoRetorno = new Date(obj.previsaoRetorno);
    this.cauteladorResponsavel = obj.cauteladorResponsavel;
    this.devolvido = obj.devolvido;
    this.dataHoraDevolucao = obj.dataHoraDevolucao ? new Date(obj.dataHoraDevolucao) : null;
    this.observacoes = obj.observacoes;
    this.createdAt = new Date(obj.createdAt);
    this.updatedAt = new Date(obj.updatedAt);
  }

  // Método para devolver a cautela
  devolver(observacoes?: string): void {
    this.devolvido = true;
    this.dataHoraDevolucao = new Date();
    if (observacoes) {
      this.observacoes = observacoes;
    }
  }

  // Método para verificar se está em atraso
  isAtrasada(): boolean {
    if (this.devolvido) return false;
    return new Date() > this.previsaoRetorno;
  }
}

export { Cautela };
````

## 2. Criando o Repository Pattern

````typescript
import { PrismaClient } from "@prisma/client";
import { Cautela } from "../adapters/Icautela";
import { ICautelaAdapter } from "../adapters/adapter";

export interface ICautelaRepository {
  findAll(): Promise<Cautela[]>;
  findById(id: string): Promise<Cautela | null>;
  findActive(): Promise<Cautela[]>;
  create(data: Omit<ICautelaAdapter, 'id' | 'createdAt' | 'updatedAt'>): Promise<Cautela>;
  update(id: string, data: Partial<ICautelaAdapter>): Promise<Cautela>;
  delete(id: string): Promise<boolean>;
}

export class CautelaRepository implements ICautelaRepository {
  constructor(private prisma: PrismaClient) {}

  async findAll(): Promise<Cautela[]> {
    const cautelas = await this.prisma.cautela.findMany({
      orderBy: { createdAt: "desc" },
    });
    return cautelas.map(cautela => new Cautela(cautela));
  }

  async findById(id: string): Promise<Cautela | null> {
    const cautela = await this.prisma.cautela.findUnique({
      where: { id },
    });
    return cautela ? new Cautela(cautela) : null;
  }

  async findActive(): Promise<Cautela[]> {
    const cautelas = await this.prisma.cautela.findMany({
      where: { devolvido: false },
      orderBy: { createdAt: "desc" },
    });
    return cautelas.map(cautela => new Cautela(cautela));
  }

  async create(data: Omit<ICautelaAdapter, 'id' | 'createdAt' | 'updatedAt'>): Promise<Cautela> {
    const cautela = await this.prisma.cautela.create({
      data: {
        ...data,
        previsaoRetorno: new Date(data.previsaoRetorno),
        dataHoraCautela: new Date(data.dataHoraCautela),
      },
    });
    return new Cautela(cautela);
  }

  async update(id: string, data: Partial<ICautelaAdapter>): Promise<Cautela> {
    const cautela = await this.prisma.cautela.update({
      where: { id },
      data,
    });
    return new Cautela(cautela);
  }

  async delete(id: string): Promise<boolean> {
    try {
      await this.prisma.cautela.delete({ where: { id } });
      return true;
    } catch {
      return false;
    }
  }
}
````

## 3. Criando o Service Layer

````typescript
import { ICautelaRepository } from "../repositories/CautelaRepository";
import { Cautela } from "../adapters/Icautela";
import { ICautelaAdapter } from "../adapters/adapter";

export interface CreateCautelaInput {
  nomeCautelador: string;
  contatoCautelador: string;
  deOnde: string;
  motivoCautela: string;
  previsaoRetorno: string;
  cauteladorResponsavel: string;
}

export interface DevolverCautelaInput {
  id: string;
  observacoes?: string;
}

export class CautelaService {
  constructor(private cautelaRepository: ICautelaRepository) {}

  async buscarTodasCautelas(): Promise<Cautela[]> {
    return await this.cautelaRepository.findAll();
  }

  async buscarCautelaPorId(id: string): Promise<Cautela | null> {
    return await this.cautelaRepository.findById(id);
  }

  async buscarCautelasAtivas(): Promise<Cautela[]> {
    return await this.cautelaRepository.findActive();
  }

  async criarCautela(input: CreateCautelaInput): Promise<Cautela> {
    const cautelaData = {
      ...input,
      dataHoraCautela: new Date(),
      devolvido: false,
      dataHoraDevolucao: null,
      observacoes: "",
    };

    return await this.cautelaRepository.create(cautelaData);
  }

  async devolverCautela(input: DevolverCautelaInput): Promise<Cautela> {
    const cautela = await this.cautelaRepository.findById(input.id);
    
    if (!cautela) {
      throw new Error("Cautela não encontrada");
    }

    if (cautela.devolvido) {
      throw new Error("Cautela já foi devolvida");
    }

    cautela.devolver(input.observacoes);

    return await this.cautelaRepository.update(input.id, {
      devolvido: true,
      dataHoraDevolucao: cautela.dataHoraDevolucao,
      observacoes: cautela.observacoes,
    });
  }
}
````

## 4. Refatorando os Resolvers com Dependency Injection

````typescript
import { PrismaClient } from "@prisma/client";
import { DateTimeResolver } from "graphql-scalars";
import { CautelaRepository } from "../repositories/CautelaRepository";
import { CautelaService, CreateCautelaInput, DevolverCautelaInput } from "../services/CautelaService";

// Dependency Injection Container
const prisma = new PrismaClient();
const cautelaRepository = new CautelaRepository(prisma);
const cautelaService = new CautelaService(cautelaRepository);

export const resolvers = {
  DateTime: DateTimeResolver,

  Query: {
    // Buscar todas as cautelas
    cautelas: async () => {
      return await cautelaService.buscarTodasCautelas();
    },

    // Buscar uma cautela específica
    cautela: async (_: any, { id }: { id: string }) => {
      const cautela = await cautelaService.buscarCautelaPorId(id);
      if (!cautela) {
        throw new Error("Cautela não encontrada");
      }
      return cautela;
    },

    // Buscar apenas cautelas ativas (não devolvidas)
    cautelasAtivas: async () => {
      return await cautelaService.buscarCautelasAtivas();
    },
  },

  Mutation: {
    // Criar nova cautela
    criarCautela: async (_: any, { input }: { input: CreateCautelaInput }) => {
      try {
        return await cautelaService.criarCautela(input);
      } catch (error) {
        throw new Error(`Erro ao criar cautela: ${error.message}`);
      }
    },

    // Devolver cautela
    devolverCautela: async (_: any, { input }: { input: DevolverCautelaInput }) => {
      try {
        return await cautelaService.devolverCautela(input);
      } catch (error) {
        throw new Error(`Erro ao devolver cautela: ${error.message}`);
      }
    },
  },
};
````

## Benefícios desta arquitetura:

1. **Separação de Responsabilidades**: Repository para acesso a dados, Service para lógica de negócio
2. **Dependency Injection**: Facilita testes e manutenção
3. **Encapsulamento**: A classe Cautela tem métodos próprios
4. **Tratamento de Erros**: Melhor controle de exceções
5. **Testabilidade**: Cada camada pode ser testada independentemente
6. **SOLID Principles**: Seguindo princípios de design orientado a objetos

Esta estrutura torna seu código mais escalável e mantível!